/*****************************************************************//**
 * \file   messaging.h
 * \brief
 *
 * \author kason
 * \date   October 2021
 *********************************************************************/

#ifndef NETWORK_MESSAGES
#define NETWORK_MESSAGES

#include <cstring>
#include <vector>

#include "types/messages.h"
#include "types/network_message_types.h"
#include "types/network_message_header.h"
#include "types/network_message_footer.h"

 /**
  * Base class for other messages.
  */
class Network_Message
{
public:
	/** Default constructor. Set type to UNDEFINED */
	Network_Message();

	/**
	 * Create a message.
	 *
	 * \param message_type Type of message created.
	 * \param types the types of data contained in the message.
	 */
	Network_Message(MESSAGES message_type, std::vector<Network_Messaging_Type*> types);
	/**
	 * Boil the Network_Message down to an array of bytes that can be padded with a header and footer and shipped on the network.
	 *
	 * \return Byte array of the message.
	 */
	std::vector<Byte> pack();
	/**
	 * Size of the array of bytes produced by Network_Message::pack()
	 *
	 * \return Size of array.
	 */
	size_t size();

	/**
	 * Return the number of fields in the message.
	 *
	 * \return Number of fields
	 */
	int number_of_fields();

	/**
	 * Convert array of bytes into the given message.
	 *
	 * \param message Array of bytes to convert.
	 * \param header_size Size of the message header so that the header can be removed.
	 */
	void unpack(std::vector<Byte> message, int header_size);

	/**
	 * \return type of the message.
	 */
	MESSAGES get_type();

	/**
	 * Get a specific data in the array of message data.
	 * \param index Index of data to get
	 * \return Data.
	 */
	Network_Messaging_Type& operator[](int index);
private:
	std::vector<Network_Messaging_Type*> message;
	MESSAGES type;
};

/**
 * A packed message waiting for sending
 * |         |       |         |
 * |:-------:|:-----:|:-------:|
 * |  01-24  | 25-n  | n+1-n+16|
 * |  Header |Message|  Footer |
 */
struct Packed_Message
{
	Packed_Message()
	{ };

	/**
	 * Constructor that sets a message up by accepting a Network_Message type.
	 * \param message Message to be the main body of the message sent on the network.
	 */
	Packed_Message(Network_Message message);

	/**
	 * Return a fully generated byte packet. This is ready to be sent over the network connections.
	 * \return byte packet.
	 */
	std::vector<Byte> get_packet();

	/**
	 * \return what this message is.
	 */
	MESSAGES get_message_type();

	/**
	 * \return Length of message as read by the header.
	 */
	int size();

private:
	/** Header */
	Message_Header header;
	/** Message to pack */
	Network_Message message;
	/** Message as a packed string */
	std::vector<Byte> packet;
	/** Footer, mainly checksums */
	Message_Footer footer;

	/**
	* Get MESSAGES based on byte 2 of the header.
	* @return The message type of the main body.
	*/
	MESSAGES get_message_enum_by_type();
};

/**
 * A message recieved from the network.
 */
struct Unpacked_Message
{
	/**
 * Constructor that sets the message data by a packet.
 * \param pack A packet to be unpacked into the message type.
 */
	Unpacked_Message(Byte_Array pack);
	/**
	 * \return Header of the message.
	 */
	Message_Header get_header();
	/**
	 * \return Footer of the message.
	 */
	Message_Footer get_footer();
	/**
	 * \return Message body.
	 */
	Network_Message get_message();

private:
	/** Header */
	Message_Header header;
	/** Message to pack */
	Network_Message message;
	/** Message as a packed string */
	std::vector<Byte> packet;
	/** Footer, mainly checksums */
	Message_Footer footer;
};

#endif // !NETWORK_MESSAGES